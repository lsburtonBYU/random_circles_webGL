<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: app.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: app.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** Call {@link drawCanvas} as soon as the DOM is loaded and parsed */
document.addEventListener("DOMContentLoaded", () => {
  // console.log("DOM loaded and parsed");
  drawCanvas(document.querySelector("#mainCanvas"));
});

/**
 * Creates and compiles a shader from GLSL source code
 *
 * @param {!WebGLRenderingContext } gl The current WebGL rendering context
 * @param {!string} shaderSource The shader source code text in GLSL
 * @param {!number} shaderType The type of shader to create, either gl.VERTEX_SHADER or gl.FRAGMENT_SHADER
 * @throws {Error} If shader cannot be compiled
 * @returns {!WebGLShader} The compiled shader
 */
function makeShader(gl, shaderSource, shaderType) {
  const newShader = gl.createShader(shaderType);
  gl.shaderSource(newShader, shaderSource);
  gl.compileShader(newShader);
  if (!gl.getShaderParameter(newShader, gl.COMPILE_STATUS)) {
    throw new Error(
      `ERROR compiling ${
        shaderType === gl.VERTEX_SHADER ? "vertex" : "fragment"
      } shader: ${gl.getShaderInfoLog(newShader)}`
    );
  }
  return newShader;
}

/**
 * Creates a WebGLProgram, attaches a vertex and a fragment shader, then links
 * the program, with the option to validate the program.
 *
 * @param {!WebGLRenderingContext } gl The current WebGL rendering context
 * @param {!WebGLShader} vertexShader A compiled vertex shader
 * @param {!WebGLShader} fragmentShader A compiled fragment shader
 * @param {boolean} validate If true, will validate the program before returning it
 * @throws {Error} If program can't be linked
 * @throws {Error} If validate is true and the program can't be validated
 * @returns {!WebGLProgram}
 */
function makeProgram(gl, vertexShader, fragmentShader, validate = true) {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);

  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error("ERROR linking program: " + gl.getProgramInfoLog(program));
  }
  if (validate) {
    gl.validateProgram(program);
    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
      throw new Error(
        "ERROR validating program: " + gl.getProgramInfoLog(program)
      );
    }
  }

  return program;
}

/**
 * Creates a program from 2 script tags.
 *
 * @param {!WebGLRenderingContext} gl The WebGL Context.
 * @param {string[]} shaderIds Array of ids names (no # prefix) of the script
 *        tags for the shaders. The first is assumed to be the
 *        vertex shader, the second the fragment shader. Default IDs are vertexShader
 *        and fragmentShader
 * @return {!WebGLProgram} A program
 */
export function makeProgramFromScripts(
  gl,
  shaderIds = ["vertexShader", "fragmentShader"]
) {
  const vertexShader = makeShader(
    gl,
    document.querySelector(`#${shaderIds[0]}`).textContent,
    gl.VERTEX_SHADER
  );

  const fragmentShader = makeShader(
    gl,
    document.querySelector(`#${shaderIds[1]}`).textContent,
    gl.FRAGMENT_SHADER
  );

  return makeProgram(gl, vertexShader, fragmentShader);
}

/**
 * Description of attribute object
 *
 * @typedef {object} AttributeObject
 * @property {string} name the name of the attribute to be used in the GLSL code
 * @property {number} size the number of elements for this attribute; must be 1,2,3, or 4
 * @property {number} stride the size in bytes of one full vertex
 * @property {number} offset the offset in bytes of this attribute in the full vertex
 * @property {number} type Data type of each component: gl.BYTE, gl.SHORT, gl.UNSIGNED_BYTE, gl.UNSIGNED_SHORT, gl.FLOAT
 * @property {boolean} normalized If true, integer data values normalized when being cast to a float
 */

/**
 * Creates an attribute object from the parameters
 *
 * @param {string} name The attribute (variable) name that will be accessed in the GLSL code
 * @param {number} numElements The number of elements for this attribute. Must be 1, 2, 3, or 4.
 * @param {number} numVertex  Number elements in the full vertex
 * @param {GLenum} type Data type of each component: gl.BYTE, gl.SHORT, gl.UNSIGNED_BYTE, gl.UNSIGNED_SHORT, gl.FLOAT
 * @param {number} offset  Offset of this attribute in the full vertex
 * @param {number} typeSize size of the data type
 * @param {boolean} normalized If true, integer data values normalized when being cast to a float
 * @returns {AttributeObject} An attribute object used in the {@link createBuffer} to set the attribute pointed
 */
export function createAttribute(
  name,
  numElements,
  numVertex,
  type,
  offset = 0,
  typeSize = Float32Array.BYTES_PER_ELEMENT,
  normalized = false
) {
  return {
    name: name,
    size: numElements,
    stride: numVertex * typeSize,
    offset: offset * typeSize,
    type: type,
    normalized: normalized,
  };
}

/**
 * Create a buffer from the buffer data and configure attributes
 *
 * @param {!WebGLRenderingContext } gl The current WebGL rendering context
 * @param {!WebGLProgram} program The WebGL complied and linked program
 * @param {!Float32Array} bufferData An array of elements
 * @param {!Array&lt;AttributeObject>} attributes Attribute descriptions generated from {@link createAttribute}
 * @param {number} type Buffer type from a GLenum; default is gl.ARRAY_BUFFER
 * @param {number} bufferDataType Buffer data type from a GLenum; default is gl.STATIC_DRAW
 */
export function createBuffer(
  gl,
  program,
  bufferData,
  attributes,
  type = gl.ARRAY_BUFFER,
  bufferDataType = gl.STATIC_DRAW
) {
  const buffer = gl.createBuffer();
  gl.bindBuffer(type, buffer);
  gl.bufferData(type, bufferData, bufferDataType);

  attributes.forEach((attr) => {
    const attrLocation = gl.getAttribLocation(program, attr.name);
    gl.vertexAttribPointer(
      attrLocation,
      attr.size,
      attr.type,
      attr.normalized,
      attr.stride,
      attr.offset
    );
    gl.enableVertexAttribArray(attrLocation);
  });
}

/**
 * Given a canvas element, uses WebGL to draw objects on it
 * @param {Element} canvas The canvas to render
 * @throws {Error} if browser does not support WebGL
 */
function drawCanvas(canvas) {
  const gl = canvas.getContext("webgl");

  if (!gl) {
    throw new Error("ERROR: browser does not support WebGL");
  }

  gl.clearColor(0.9, 0.9, 0.9, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const program = makeProgramFromScripts(gl);

  //
  // Set up buffer data and associated attributes
  //
  // prettier-ignore
  const bufferData = new Float32Array([
    // X, Y,       R, G, B
      0.0,  0.8,   1.0, 1.0, 0.0, 
     -0.8, -0.8,   0.7, 0.0, 1.0, 
      0.8, -0.8,   0.1, 1.0, 0.6,
  ]);

  const attributes = new Array(
    // vertPosition is 2 elements in a 5 element vertex
    createAttribute("vertPosition", 2, 5, gl.FLOAT),

    // vertColor is 3 elements in a 5 element vertex beginning at offset [2]
    createAttribute("vertColor", 3, 5, gl.FLOAT, 2)
  );

  //
  // Create buffer from buffer data and attributes
  //
  createBuffer(gl, program, bufferData, attributes);

  //
  // Main render loop
  //
  gl.useProgram(program);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#createAttribute">createAttribute</a></li><li><a href="global.html#createBuffer">createBuffer</a></li><li><a href="global.html#drawCanvas">drawCanvas</a></li><li><a href="global.html#makeProgram">makeProgram</a></li><li><a href="global.html#makeProgramFromScripts">makeProgramFromScripts</a></li><li><a href="global.html#makeShader">makeShader</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Wed May 04 2022 19:54:05 GMT-0600 (Mountain Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
